/*
 * main.c
 *
 *  Created on: 24.04.2015
 *      Author: David
 */


#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <CL/opencl.h>
#include <windows.h>


cl_event eventLoadReady;
cl_event eventProcessReady;

cl_event eventLoadReady2;
cl_event eventProcessReady2;

cl_event eventsProcessReady[2];

cl_uint ret_num_devices;

HANDLE writeDataThread;
HANDLE processDataThread;

//Length of vectors
unsigned int n = 10;

// Host input vectors
float *h_a = NULL;
float *h_b  = NULL;

float *h_a2  = NULL;
float *h_b2  = NULL;
// Host output vector
float *h_c  = NULL;
float *h_c2  = NULL;

// Device input buffers
cl_mem d_a;
cl_mem d_b;

cl_mem d_a2;
cl_mem d_b2;
// Device output buffer
cl_mem d_c;
cl_mem d_c2;


cl_platform_id cpPlatform;        // OpenCL platform
cl_device_id device_id;           // device ID
cl_context context;               // context
cl_command_queue queue;           // command queue
cl_program program;               // program
cl_kernel kernel;                 // kernel

DWORD WINAPI loadData(void* data)
{
	// Size, in bytes, of each vector
	size_t bytes = n*sizeof(float);
	cl_command_queue queueWrite = clCreateCommandQueue(context, device_id, 0, 0);
	printf("start loaddata\n");
	// Write our data set into the input array in device memory
	clEnqueueWriteBuffer(queueWrite, d_a, CL_TRUE, 0, bytes, h_a, 0, NULL, NULL);
	clEnqueueWriteBuffer(queueWrite, d_b, CL_TRUE, 0, bytes, h_b, 0, NULL, NULL);
	clSetUserEventStatus(eventLoadReady, CL_COMPLETE);
	printf("loaddata1\n");
	// Write our data set into the input array in device memory
	clEnqueueWriteBuffer(queueWrite, d_a2, CL_TRUE, 0, bytes, h_a2, 0, NULL, NULL);
	clEnqueueWriteBuffer(queueWrite, d_b2, CL_TRUE, 0, bytes, h_b2, 0, NULL, NULL);
	clSetUserEventStatus(eventLoadReady2, CL_COMPLETE);
	printf("loaddata2\n");
	return NULL;
}



DWORD WINAPI processData(void* data)
{

	size_t bytes = n*sizeof(float);
	cl_command_queue queueProcess = clCreateCommandQueue(context, device_id, 0, 0);
	printf("startprocessdata\n");
	// Read the results from the device
	clWaitForEvents( 1,  &eventProcessReady);
	clEnqueueReadBuffer(queueProcess, d_c, CL_TRUE, 0, bytes, h_c, 1, &eventProcessReady, NULL );
	printf("processdata1\n");
	//clWaitForEvents( 1,  &eventProcessReady2);
	clEnqueueReadBuffer(queueProcess, d_c2, CL_TRUE, 0, bytes, h_c2, 1, &eventProcessReady2, NULL );
	printf("processdata2\n");
	return NULL;
}

const char *ksrc(const char * filename) {
	char * buffer;
	long lSize;
	FILE * fp;

	fp = fopen (filename, "rb" );
	if( !fp ) perror(filename),exit(1);

	//get filesize
	fseek(fp , 0L , SEEK_END);
	lSize = ftell(fp);
	rewind(fp);

	buffer = (char *)calloc(1, lSize+1);
	if(!buffer) fclose(fp),fputs("memory alloc fails",stderr),exit(1);

	if( 1!=fread( buffer , lSize, 1 , fp) )
		fclose(fp),free(buffer),fputs("entire read fails",stderr),exit(1);

	fclose(fp);
	return buffer;;
}

void info(cl_device_id device) {
	char device_string[1024];
	size_t workgroups;

	clGetDeviceInfo(device, CL_DEVICE_NAME, sizeof(device_string), &device_string, NULL);
	printf("CL_DEVICE_NAME: \t\t\t%s\n", device_string);

	// CL_DEVICE_VENDOR
	clGetDeviceInfo(device, CL_DEVICE_VENDOR, sizeof(device_string), &device_string, NULL);
	printf("CL_DEVICE_VENDOR: \t\t\t%s\n", device_string);

	// CL_DRIVER_VERSION
	clGetDeviceInfo(device, CL_DRIVER_VERSION, sizeof(device_string), &device_string, NULL);
	printf("CL_DRIVER_VERSION: \t\t\t%s\n", device_string);

	// Max work group size
	clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(workgroups), &workgroups, NULL);
	printf("Max work group size: \t\t\t%d\n", (int)workgroups);
}

int main() {

	DWORD wDThreadId, wDThrdParam = 1;
	DWORD pDThreadId, pDThrdParam = 1;
	int i=0;
	float sum = 0;
	float sum2 = 0;
	const char *kernelSource = ksrc(".\Kernel\reduction.cl");
	size_t globalSize, localSize;
	cl_int err;
	// Size, in bytes, of each vector
	size_t bytes = n*sizeof(float);

	// Aray to store thread handles
    HANDLE Array_Of_Thread_Handles[2];

	// Allocate memory for each vector on host
	h_a = (float*)malloc(bytes);
	h_b = (float*)malloc(bytes);
	h_c = (float*)malloc(bytes);

	h_a2 = (float*)malloc(bytes);
	h_b2 = (float*)malloc(bytes);
	h_c2 = (float*)malloc(bytes);

	// Initialize vectors on host

	for( i = 0; i < n; i++ )
	{
		h_a[i] = sinf(i)*sinf(i);
		h_b[i] = cosf(i)*cosf(i);

		h_a2[i] = h_a[i];// sinf(i)*sinf(i);
		h_b2[i] = h_b[i];// cosf(i)*cosf(i);
	}



	// Number of work items in each local work group
	localSize = 64;

	// Number of total work items - localSize must be devisor
	globalSize = ceil(n/(float)localSize)*localSize;

	// Bind to platform
	err = clGetPlatformIDs(1, &cpPlatform, NULL);

	// Get ID for the device
	err = clGetDeviceIDs(cpPlatform, CL_DEVICE_TYPE_GPU, 1, &device_id, &ret_num_devices);
	info(device_id);

	// Create a context
	context = clCreateContext(0, 1, &device_id, NULL, NULL, &err);

	// Create a command queue
	queue = clCreateCommandQueue(context, device_id, 0, &err);

	// Create the compute program from the source buffer
	program = clCreateProgramWithSource(context, 1, (const char **) & kernelSource, NULL, &err);

	// Build the program executable
	clBuildProgram(program, 0, NULL, NULL, NULL, NULL);

	// Create the compute kernel in the program we wish to run
	kernel = clCreateKernel(program, "vecAdd", &err);

	// Create the input and output arrays in device memory for our calculation
	d_a = clCreateBuffer(context, CL_MEM_READ_ONLY, bytes, NULL, NULL);
	d_b = clCreateBuffer(context, CL_MEM_READ_ONLY, bytes, NULL, NULL);
	d_c = clCreateBuffer(context, CL_MEM_WRITE_ONLY, bytes, NULL, NULL);

	d_a2 = clCreateBuffer(context, CL_MEM_READ_ONLY, bytes, NULL, NULL);
	d_b2 = clCreateBuffer(context, CL_MEM_READ_ONLY, bytes, NULL, NULL);
	d_c2 = clCreateBuffer(context, CL_MEM_WRITE_ONLY, bytes, NULL, NULL);

	eventLoadReady = clCreateUserEvent(context, &err);
	eventProcessReady = clCreateUserEvent(context, &err);

	eventLoadReady2 = clCreateUserEvent(context, &err);
	eventProcessReady2 = clCreateUserEvent(context, &err);

	 writeDataThread = CreateThread(
			NULL, // default security attributes
			0, // use default stack size
			loadData, // thread function
			NULL, // argument to thread function
			0, // use default creation flags
			NULL); // returns the thread identifier

	 if( writeDataThread)
	 {

		 // Set the arguments to our compute kernel
		err  = clSetKernelArg(kernel, 0, sizeof(cl_mem), &d_a);
		err |= clSetKernelArg(kernel, 1, sizeof(cl_mem), &d_b);
		err |= clSetKernelArg(kernel, 2, sizeof(cl_mem), &d_c);
		err |= clSetKernelArg(kernel, 3, sizeof(unsigned int), &n);
		// Execute the kernel over the entire range of the data set
		printf("Setkernelarg 1\n");
		err = clEnqueueNDRangeKernel(queue, kernel, 1, NULL, &globalSize, &localSize, 1,  &eventLoadReady, &eventProcessReady);
		//clSetUserEventStatus(eventProcessReady, CL_COMPLETE);


		err  = clSetKernelArg(kernel, 0, sizeof(cl_mem), &d_a2);
		err |= clSetKernelArg(kernel, 1, sizeof(cl_mem), &d_b2);
		err |= clSetKernelArg(kernel, 2, sizeof(cl_mem), &d_c2);
		err |= clSetKernelArg(kernel, 3, sizeof(unsigned int), &n);
		printf("Setkernelarg 2\n");
		err = clEnqueueNDRangeKernel(queue, kernel, 1, NULL, &globalSize, &localSize, 1,  &eventLoadReady2, &eventProcessReady2);
		//clSetUserEventStatus(eventProcessReady2, CL_COMPLETE);
	 }

	processDataThread = CreateThread(
			NULL, // default security attributes
			0, // use default stack size
			processData, // thread function
			NULL, // argument to thread function
			0, // use default creation flags
			NULL); // returns the thread identifier

	printf("waitthread\n");
	Array_Of_Thread_Handles[0] = writeDataThread;
	Array_Of_Thread_Handles[1] = processDataThread;
	//WaitForSingleObject(&writeDataThread, INFINITE);
	//WaitForSingleObject(&processDataThread, INFINITE);
	WaitForMultipleObjects( 2, Array_Of_Thread_Handles, TRUE, INFINITE);
	printf("finish\n");

	clFlush(queue);
	clFinish(queue);

	//CloseHandle(*processDataThread);
	//CloseHandle(*writeDataThread);

	// Read the results from the device
	//clEnqueueReadBuffer(queue, d_c, CL_TRUE, 0, bytes, h_c, 1, &eventsProcessReady[0], NULL );

	//Sum up vector c and print result divided by n, this should equal 1 within error

	for(i=0; i<n; i++) {
		sum += h_c[i];
		sum2 += h_c2[i];
	}
	printf("final result: %f\n", sum/n);
	printf("final result: %f\n", sum2/n);

	// release OpenCL resources
	clReleaseMemObject(d_a);
	clReleaseMemObject(d_b);
	clReleaseMemObject(d_c);
	clReleaseProgram(program);
	clReleaseKernel(kernel);
	clReleaseCommandQueue(queue);
	clReleaseContext(context);

	//release host memory
	free(h_a);
	free(h_b);
	free(h_c);
	system("Pause");
	return EXIT_SUCCESS;
}
